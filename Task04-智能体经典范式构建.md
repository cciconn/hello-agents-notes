# Task04：智能体经典范式构建学习笔记

## 学习内容
1. 环境准备与基础工具定义
1.1 安装依赖库：openai和python-dotenv
1.2 配置API密钥：在项目根目录下创建名为.env的文件
1.3 封装基础LLM调用函数
2. ReAct：由ShunyuYao于2022年提出，其核心思想是模仿人类解决问题的方式，将推理 (Reasoning) 与行动 (Acting) 显式地结合起来，形成一个“思考-行动-观察”的循环。
2.1 ReAct的工作流程
   <img width="1496" height="536" alt="image" src="https://github.com/user-attachments/assets/cdcf6ad1-241b-46f5-a927-a215b98dc041" />
2.2 工具的定义与实现
   <img width="1896" height="1888" alt="image" src="https://github.com/user-attachments/assets/103e8ab4-89b8-413a-8116-af34bd0b70d7" />
2.3 ReAct智能体的编码实现
   <img width="1896" height="1888" alt="image" src="https://github.com/user-attachments/assets/1d0cf8b3-105f-4fb7-88c8-2bb1cce7c9eb" />
2.4 ReAct 的特点、局限性与调试技巧
   （1）ReAct 的主要特点：高可解释性，动态规划与纠错能力，工具协同能力
   （2）ReAct 的固有局限性：对LLM自身能力的强依赖，执行效率问题，提示词的脆弱性，可能陷入局部最优
   （3）调试技巧：检查完整的提示词，分析原始输出，验证工具的输入与输出，调整提示词中的示例，尝试不同的模型或参数
3. Plan-and-Solve：顾名思义，这种范式将任务处理明确地分为两个阶段：先规划 (Plan)，后执行 (Solve)。
3.1 Plan-and-Solve 的工作原理   
  <img width="1480" height="704" alt="image" src="https://github.com/user-attachments/assets/75e4088c-f915-417c-b2da-a89ed48a4423" />
3.2 规划阶段
3.3 执行器与状态管理
3.4 运行实例与分析
   <img width="1896" height="1888" alt="image" src="https://github.com/user-attachments/assets/d011983d-84f8-49f7-8d24-0d90d1b53a59" />
4. Reflection：Reflection 机制的核心思想，正是为智能体引入一种事后（post-hoc）的自我校正循环，使其能够像人类一样，审视自己的工作，发现不足，并进行迭代优化。
4.1 Reflection 机制的核心思想：执行，反思，优化
   <img width="1188" height="1076" alt="image" src="https://github.com/user-attachments/assets/22c1afc6-7703-4b1a-8e24-e2b9db057cc6" />
4.2 案例设定与记忆模块设计
4.3 Reflection智能体的编码实现
4.4 运行实例与分析
   <img width="1896" height="1888" alt="image" src="https://github.com/user-attachments/assets/d5f06017-d9b4-4cb2-8809-0ca5b807bc6a" />
4.5 Reflection机制的成本收益分析：Reflection 机制是一种典型的“以成本换质量”的策略。它非常适合那些对最终结果的质量、准确性和可靠性
有极高要求，且对任务完成的实时性要求相对宽松的场景。
   （1）主要成本：模型调用开销增加，任务延迟显著提高，提示工程复杂度上升
   （2）核心收益：解决方案质量的跃迁，鲁棒性与可靠性增强

## 习题
1.
- 区别：ReAct：思考与行动交替进行，实时交互。Plan-and-Solve：先集中思考规划，后集中行动执行，思考与行动分离。Reflection：思考（反思）发生在行动之后，用于评估和改进。
- 选择ReAct，因为智能家居环境动态变化，需要实时推理和行动，ReAct能灵活适应环境变化和用户习惯。
- 可以组合，设计场景如下：
  步骤1：当接收到一个复杂任务（如“准备睡眠环境”）时，智能体首先进行规划（Plan），分解任务为子任务（例如：关闭客厅灯光、调节卧室空调温度、关闭窗帘等）。
步骤2：对于每个子任务，智能体进入ReAct循环：
   推理（Reason）：根据当前环境状态（如当前灯光状态、温度等）和用户习惯，决定下一步行动。
   行动（Act）：执行控制命令（如关闭灯光）。
   反思（Reflect）：检查行动结果（如灯光是否已关闭），如果失败，则重新尝试或调整；同时，记录这次行动的效果，用于更新用户习惯模型。
步骤3：在整个任务完成后，进行一次整体反思，总结本次任务执行的成功与不足，更新用户习惯模型，以便未来更好地自动调节。

2.
- 模型输出可能不严格遵循我们指定的格式，比如在Thought或Action前后添加了额外内容，或者使用了不同的标点。如果模型在Thought或Action内容中使用了与格式相同的关键词（比如在Thought中包含了“Action:”这样的字符串），可能导致解析错误。
- 使用更结构化的输出，比如JSON。
- <img width="1896" height="1888" alt="image" src="https://github.com/user-attachments/assets/1258a6b9-01cf-43aa-87ed-49836c0ce0b9" />
<img width="1468" height="304" alt="image" src="https://github.com/user-attachments/assets/d838c52c-1379-4c23-8d80-9ee282f479c7" />

3.

4.
- 工作流程：执行→监控→失败检测→策略选择→重新规划→继续执行
- Plan-and-Solve更适合，原因：
   全局优化需求：需要协调机票、酒店、租车的时间地点一致性
   约束复杂：预算、时间衔接、地理位置等约束需要一次性考虑
   确定性较高：预订任务步骤相对明确，不确定性较低
   效率考量：一次性规划后批量执行比交互式逐步执行更高效
- 核心优势：
   降低复杂性：将复杂问题分解为多个抽象层级，每层专注本级问题
   提高可复用性：高层计划可复用于类似场景，只需调整底层细节
   增强容错性：低层失败可在同层或上层解决，不影响整体结构
   支持增量细化：可先制定粗略计划再逐步细化
   便于并行规划：不同层级/分支可并行规划
   优化决策质量：每层可进行本级最优决策，全局约束可向下传播

5.
- 反思更精准，执行更快
- 改进幅度<5%就停或者根据任务难度自动调次数
- 设计"论文健康体检"：
   段落逻辑：检查"过渡自然吗？论点递进吗？"
   方法创新：问"这是真创新还是改了0.1%参数？"
   语言表达："这个方法很厉害"→"该方法在准确率与效率的权衡上实现了显著突破（p<0.01）"
   引用规范：自动检测"参考文献[5]缺少页码，建议按APA格式补充"

6.
- ReAct采用“思考-行动-观察”循环结构，支持动态交互调整，适用于不确定环境下的探索性任务，体现试错学习逻辑。Plan-and-Solve采用“先规划后执行”线性结构，强调预先系统性分解，适用于结构化明确任务，体现工程化思维。结构差异直接服务于各自的核心范式：ReAct重在适应性，Plan-and-Solve重在可靠性。
- 将“严格代码评审专家”改为“注重可读性的开源维护者”后，输出从关注正确性、安全性转向关注可读性、维护性，语气从批判性变为建设性。角色设定实质是为模型植入不同的价值偏好和注意力分布，通过改变认知框架来引导输出风格和重点，是提示词工程中的高效调控手段。
- 

7.







